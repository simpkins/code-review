#!/usr/local/bin/python -tt
#
# Copyright 2010 Facebook, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License. You may obtain
# a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.
#
"""
This script takes a unified diff as input, and outputs a new unified diff with
less context around each hunk.

This is useful if someone gives you a diff with a very large amount of context,
but it won't apply against your repository.

This can be used to reduce the amount of context, in case the changes are just
in the surrounding context.  Many patching utilities have this functionality
built-in (e.g., 'patch -F', 'git apply -C').  However, being able to manually
reduce the context is useful if there are legitimate conflicts in the modified
code:  The patch utility only marks rejected hunks; if there are only a few
hunks with a giant amount of context each, it is still very difficult to track
down the precise conflict.
"""
import optparse
import os
import sys

import gitreview.diff

RETCODE_SUCCESS = 0
RETCODE_ARGUMENTS_ERROR = 1

f_progname = os.path.basename(sys.argv[0])


class OptionsError(Exception):
    pass


class UsageError(Exception):
    pass


class Options(optparse.OptionParser):
    def __init__(self):
        optparse.OptionParser.__init__(self, add_help_option=False,
                                       usage='%prog [options]')
        self.add_option('-C', '--context',
                        action='store', dest='context', default=3,
                        help='Amount of context to retain in the output')
        self.add_option('-?', '--help',
                        action='callback', callback=self.__help_callback,
                        help='Print this help message and exit')

    def __help_callback(self, option, opt, value, parser):
        raise UsageError()

    def error(self, msg):
        # This is called automatically by optparse when an error in the command
        # line options is encountered.
        raise OptionsError(msg)

    def __getattr__(self, name):
        # Allow members of self.__options to be accessed directly
        if name.startswith('__'):
            raise AttributeError(name)
        return getattr(self.__options, name)

    def parse_argv(self, argv):
        # parse the options
        (self.__options, args) = self.parse_args(argv[1:])

        # Argument post-processing
        try:
            self.context = int(self.__options.context)
        except ValueError:
            raise OptionsError('invalid context argument: must be an integer')
        if self.context < 0:
            raise OptionsError('amount of context may not be negative')

        # Parse the remaining arguments
        num_args = len(args)
        if num_args == 0:
            self.in_path = None
            self.out_path = None
        elif num_args == 1:
            self.in_path = args[0]
            self.out_path = None
        elif num_args == 2:
            self.in_path = args[0]
            self.out_path = args[1]
        else:
            raise OptionsError('trailing arguments: ' + ' '.join(args[2:]))


def error_msg(msg):
    sys.stderr.write('%s: error: %s\n' % (f_progname, msg))


def warning_msg(msg):
    sys.stderr.write('%s: warning: %s\n' % (f_progname, msg))


def main(argv):
    # Parse the command line options
    options = Options()
    try:
        options.parse_argv(argv)
    except OptionsError, error:
        options.print_usage(sys.stderr)
        error_msg(error)
        return RETCODE_ARGUMENTS_ERROR
    except UsageError, error:
        options.print_help()
        return RETCODE_SUCCESS

    if options.in_path is None:
        fin = sys.stdin
    else:
        fin = open(options.in_path, 'r')

    if options.out_path is None:
        fout = sys.stdout
    else:
        fout = open(options.out_path, 'w')

    diff = gitreview.diff.UnifiedDiffParser(fin).parse()

    new_diff = gitreview.diff.Diff()
    for file in diff.files:
        new_file = gitreview.diff.FileSection(file.old_path, file.new_path)
        new_diff.files.append(new_file)
        for hunk in file.hunks:
            new_hunks = hunk.split(context=options.context)
            new_file.hunks.extend(new_hunks)

    gitreview.diff.UnifiedDiffFormatter(fout).write(new_diff)
    return RETCODE_SUCCESS


if __name__ == '__main__':
    sys.exit(main(sys.argv))
